/*
Identity Mapper Service
Manages PID-to-Identity mapping with eBPF integration
*/

package identity

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
)

// Identity represents an agent's identity
type Identity struct {
	AgentID        string
	TenantID       string // Userspace ID
	TenantHash     uint32 // Kernel ID (hashed)
	TrustLevel     uint32 // 0-10000 (trust score * 100)
	SPIFFESVIDHash uint64
	RegisteredAt   uint64
	ParentPID      uint32
}

// IdentityEvent from eBPF
type IdentityEvent struct {
	PID       uint32
	ParentPID uint32
	EventType uint8 // 0=fork, 1=exec, 2=exit, 3=lookup
	AgentID   [36]byte
	Timestamp uint64
}

// IdentityMapper manages PIDâ†’AgentID mappings
type IdentityMapper struct {
	objs       *ebpfObjects
	links      []link.Link
	reader     *perf.Reader
	identities map[uint32]*Identity // PID â†’ Identity cache
	mu         sync.RWMutex
	eventChan  chan *IdentityEvent
	stopChan   chan struct{}
}

// ebpfObjects placeholder (generated by bpf2go)
type ebpfObjects struct {
	PidIdentityMap ebpf.Map `ebpf:"pid_identity_map"`
	IdentityEvents ebpf.Map `ebpf:"identity_events"`
}

// NewIdentityMapper creates a new identity mapper
func NewIdentityMapper() (*IdentityMapper, error) {
	im := &IdentityMapper{
		identities: make(map[uint32]*Identity),
		eventChan:  make(chan *IdentityEvent, 1000),
		stopChan:   make(chan struct{}),
	}

	// Load eBPF program
	if err := im.loadeBPF(); err != nil {
		return nil, fmt.Errorf("failed to load eBPF: %w", err)
	}

	// Attach hooks
	if err := im.attachHooks(); err != nil {
		return nil, fmt.Errorf("failed to attach hooks: %w", err)
	}

	// Start event processor
	go im.processEvents()

	return im, nil
}

// loadeBPF loads the eBPF program
func (im *IdentityMapper) loadeBPF() error {
	log.Println("ðŸ“¡ Loading PID-to-Identity eBPF program...")

	// In production, use bpf2go generated code
	// spec, err := ebpf.LoadCollectionSpec("identity_map.bpf.o")
	// if err != nil {
	//     return err
	// }
	//
	// im.objs = &ebpfObjects{}
	// return spec.LoadAndAssign(im.objs, nil)

	return nil
}

// attachHooks attaches eBPF hooks
func (im *IdentityMapper) attachHooks() error {
	log.Println("ðŸ”— Attaching identity hooks...")

	// Attach to sched_process_fork
	// tp, err := link.Tracepoint("sched", "sched_process_fork", im.objs.TraceFork, nil)
	// if err != nil {
	//     return err
	// }
	// im.links = append(im.links, tp)

	// Attach to sched_process_exec
	// Similar...

	// Attach to sched_process_exit
	// Similar...

	// Attach to tcp_connect
	// kp, err := link.Kprobe("tcp_connect", im.objs.KprobeTcpConnect, nil)
	// if err != nil {
	//     return err
	// }
	// im.links = append(im.links, kp)

	return nil
}

// RegisterAgent registers a new agent with PID
func (im *IdentityMapper) RegisterAgent(pid uint32, agentID, tenantID string, trustScore float64, spiffeHash uint64) error {
	im.mu.Lock()
	defer im.mu.Unlock()

	// Compute Tenant Hash
	tenantHash := hashTenantID(tenantID)

	// Create identity
	identity := &Identity{
		AgentID:        agentID,
		TenantID:       tenantID,
		TenantHash:     tenantHash,
		TrustLevel:     uint32(trustScore * 100),
		SPIFFESVIDHash: spiffeHash,
		RegisteredAt:   uint64(time.Now().Unix()),
		ParentPID:      0,
	}

	// Store in local cache
	im.identities[pid] = identity

	// Update eBPF map
	if err := im.updateeBPFMap(pid, identity); err != nil {
		return err
	}

	log.Printf("âœ… Registered agent: PID=%d, Tenant=%s, AgentID=%s, Trust=%.2f", pid, tenantID, agentID, trustScore)
	return nil
}

// hashTenantID converts string tenantID to u32 for eBPF
func hashTenantID(tenantID string) uint32 {
	// Simple FNV-1a like hash or crc32
	var h uint32 = 0x811c9dc5
	for i := 0; i < len(tenantID); i++ {
		h ^= uint32(tenantID[i])
		h *= 0x01000193
	}
	return h
}

// updateeBPFMap updates the kernel eBPF map
func (im *IdentityMapper) updateeBPFMap(pid uint32, identity *Identity) error {
	// In production, update the actual eBPF map
	// key := pid
	// value := identityT{
	//     BinaryHash:     identity.SPIFFESVIDHash, // Mapping raw hash to internal field
	//     TenantID:       identity.TenantHash,
	// }
	// return im.objs.PidIdentityMap.Update(key, value, ebpf.UpdateAny)

	return nil
}

// VerifyIdentity verifies a PID's identity
func (im *IdentityMapper) VerifyIdentity(pid uint32, claimedAgentID string) (bool, error) {
	im.mu.RLock()
	defer im.mu.RUnlock()

	// Check local cache first
	identity, ok := im.identities[pid]
	if !ok {
		// Check eBPF map
		identity, err := im.lookupeBPFMap(pid)
		if err != nil {
			return false, fmt.Errorf("identity not found for PID %d", pid)
		}

		// Cache it
		im.identities[pid] = identity
	}

	// Verify claimed identity matches
	if identity.AgentID != claimedAgentID {
		log.Printf("âš ï¸  Identity mismatch: PID=%d claimed=%s actual=%s", pid, claimedAgentID, identity.AgentID)
		return false, nil
	}

	return true, nil
}

// lookupeBPFMap looks up identity from eBPF map
func (im *IdentityMapper) lookupeBPFMap(pid uint32) (*Identity, error) {
	// In production, lookup from eBPF map
	// var value identityT
	// if err := im.objs.PidIdentityMap.Lookup(pid, &value); err != nil {
	//     return nil, err
	// }
	//
	// return &Identity{
	//     AgentID:        string(value.AgentID[:]),
	//     TrustLevel:     value.TrustLevel,
	//     SPIFFESVIDHash: value.SPIFFESVIDHash,
	//     RegisteredAt:   value.RegisteredAt,
	//     ParentPID:      value.ParentPID,
	// }, nil

	return nil, fmt.Errorf("not implemented")
}

// GetIdentity returns identity for a PID
func (im *IdentityMapper) GetIdentity(pid uint32) (*Identity, error) {
	im.mu.RLock()
	defer im.mu.RUnlock()

	identity, ok := im.identities[pid]
	if !ok {
		return im.lookupeBPFMap(pid)
	}

	return identity, nil
}

// UnregisterAgent removes an agent's identity
func (im *IdentityMapper) UnregisterAgent(pid uint32) error {
	im.mu.Lock()
	defer im.mu.Unlock()

	delete(im.identities, pid)

	// Delete from eBPF map
	// return im.objs.PidIdentityMap.Delete(pid)

	log.Printf("ðŸ—‘ï¸  Unregistered agent: PID=%d", pid)
	return nil
}

// processEvents processes identity events from eBPF
func (im *IdentityMapper) processEvents() {
	// In production, read from perf event array
	// for {
	//     select {
	//     case <-im.stopChan:
	//         return
	//     default:
	//         record, err := im.reader.Read()
	//         if err != nil {
	//             continue
	//         }
	//
	//         event := im.parseEvent(record.RawSample)
	//         im.handleEvent(event)
	//     }
	// }
}

// parseEvent parses raw eBPF event
func (im *IdentityMapper) parseEvent(data []byte) *IdentityEvent {
	event := &IdentityEvent{}

	buf := bytes.NewReader(data)
	binary.Read(buf, binary.LittleEndian, &event.PID)
	binary.Read(buf, binary.LittleEndian, &event.ParentPID)
	binary.Read(buf, binary.LittleEndian, &event.EventType)
	binary.Read(buf, binary.LittleEndian, &event.AgentID)
	binary.Read(buf, binary.LittleEndian, &event.Timestamp)

	return event
}

// handleEvent handles an identity event
func (im *IdentityMapper) handleEvent(event *IdentityEvent) {
	agentID := string(bytes.TrimRight(event.AgentID[:], "\x00"))

	switch event.EventType {
	case 0: // fork
		log.Printf("ðŸ‘¶ Fork: PID=%d inherited identity from parent=%d (Agent=%s)", event.PID, event.ParentPID, agentID)

	case 1: // exec
		log.Printf("ðŸ”„ Exec: PID=%d maintained identity (Agent=%s)", event.PID, agentID)

	case 2: // exit
		log.Printf("ðŸ’€ Exit: PID=%d (Agent=%s)", event.PID, agentID)
		im.UnregisterAgent(event.PID)

	case 3: // lookup
		log.Printf("ðŸ” Lookup: PID=%d (Agent=%s)", event.PID, agentID)
	}
}

// GetStats returns identity statistics
func (im *IdentityMapper) GetStats() map[string]interface{} {
	im.mu.RLock()
	defer im.mu.RUnlock()

	return map[string]interface{}{
		"total_identities": len(im.identities),
		"active_pids":      len(im.identities),
	}
}

// Close cleanup
func (im *IdentityMapper) Close() error {
	close(im.stopChan)

	for _, l := range im.links {
		l.Close()
	}

	if im.reader != nil {
		im.reader.Close()
	}

	return nil
}

// GetAgentID returns AgentID for a PID
func (event *IdentityEvent) GetAgentID() string {
	return string(bytes.TrimRight(event.AgentID[:], "\x00"))
}
