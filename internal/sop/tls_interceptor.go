/*
TLS Event Handler
Processes plaintext TLS data from eBPF uProbes
*/

package sop

import (
	"fmt"
	"log/slog"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
)

// TLSEvent matches the eBPF struct
type TLSEvent struct {
	PID       uint32
	TID       uint32
	Timestamp uint64
	DataLen   uint32
	Direction uint8 // 0 = write, 1 = read
	Library   uint8 // 0 = OpenSSL, 1 = BoringSSL, 2 = Go
	Data      [4096]byte
	Comm      [16]byte
}

// TLSInterceptor manages eBPF TLS uProbes
type TLSInterceptor struct {
	objs      *ebpfObjects
	links     []link.Link
	reader    *perf.Reader
	eventChan chan *TLSEvent
	stopChan  chan struct{}
}

// ebpfObjects placeholder (generated by bpf2go)
type ebpfObjects struct {
	TlsEvents ebpf.Map `ebpf:"tls_events"`
}

// NewTLSInterceptor creates a new TLS interceptor
func NewTLSInterceptor() (*TLSInterceptor, error) {
	ti := &TLSInterceptor{
		eventChan: make(chan *TLSEvent, 1000),
		stopChan:  make(chan struct{}),
	}

	// Load eBPF program
	if err := ti.loadeBPF(); err != nil {
		return nil, fmt.Errorf("failed to load eBPF: %w", err)
	}

	// Attach uProbes
	if err := ti.attachProbes(); err != nil {
		return nil, fmt.Errorf("failed to attach probes: %w", err)
	}

	// Start event reader
	go ti.readEvents()

	return ti, nil
}

// loadeBPF loads the eBPF program
func (ti *TLSInterceptor) loadeBPF() error {
	// In production, this would use bpf2go generated code
	// For now, placeholder
	slog.Info("Loading TLS interception eBPF program...")
	// Load compiled eBPF object
	// spec, err := ebpf.LoadCollectionSpec("tls_uprobe.bpf.o")
	// if err != nil {
	//     return err
	// }

	// ti.objs = &ebpfObjects{}
	// return spec.LoadAndAssign(ti.objs, nil)

	return nil
}

// attachProbes attaches uProbes to SSL libraries
func (ti *TLSInterceptor) attachProbes() error {
	slog.Info("Attaching TLS uProbes...")
	// Attach to OpenSSL
	if err := ti.attachOpenSSL(); err != nil {
		slog.Warn("OpenSSL attach failed", "error", err)
	}

	// Attach to BoringSSL
	if err := ti.attachBoringSSL(); err != nil {
		slog.Warn("BoringSSL attach failed", "error", err)
	}

	// Attach to Go crypto/tls
	if err := ti.attachGoCrypto(); err != nil {
		slog.Warn("Go crypto attach failed", "error", err)
	}

	return nil
}

// attachOpenSSL attaches uProbes to OpenSSL functions
func (ti *TLSInterceptor) attachOpenSSL() error {
	// Find OpenSSL library
	libPath := findLibrary("libssl.so")
	if libPath == "" {
		return fmt.Errorf("libssl.so not found")
	}

	slog.Info("Found OpenSSL", "lib_path", libPath)
	// Attach SSL_write
	// ex, err := link.OpenExecutable(libPath)
	// if err != nil {
	//     return err
	// }

	// up, err := ex.Uprobe("SSL_write", ti.objs.UprobeSSLWrite, nil)
	// if err != nil {
	//     return err
	// }
	// ti.links = append(ti.links, up)

	// Attach SSL_read
	// Similar for SSL_read...

	return nil
}

// attachBoringSSL attaches uProbes to BoringSSL
func (ti *TLSInterceptor) attachBoringSSL() error {
	// Similar to OpenSSL
	return nil
}

// attachGoCrypto attaches uProbes to Go crypto/tls
func (ti *TLSInterceptor) attachGoCrypto() error {
	// Find Go binaries
	// Attach to (*Conn).Write and (*Conn).Read
	return nil
}

// findLibrary finds a shared library by name
func findLibrary(name string) string {
	// Common library paths
	paths := []string{
		"/usr/lib/x86_64-linux-gnu/" + name,
		"/usr/lib64/" + name,
		"/lib/x86_64-linux-gnu/" + name,
		"/lib64/" + name,
	}

	for range paths {
		// Check if file exists
		// if _, err := os.Stat(path); err == nil {
		//     return path
		// }
	}

	return ""
}

// readEvents reads TLS events from eBPF
func (ti *TLSInterceptor) readEvents() {
	// In production, read from perf event array
	// for {
	//     select {
	//     case <-ti.stopChan:
	//         return
	//     default:
	//         record, err := ti.reader.Read()
	//         if err != nil {
	//             continue
	//         }
	//
	//         event := ti.parseEvent(record.RawSample)
	//         ti.eventChan <- event
	//     }
	// }
}

// GetEventChannel returns the event channel
func (ti *TLSInterceptor) GetEventChannel() <-chan *TLSEvent {
	return ti.eventChan
}

// ProcessEvent processes a TLS event
func (ti *TLSInterceptor) ProcessEvent(event *TLSEvent) {
	direction := "WRITE"
	if event.Direction == 1 {
		direction = "READ"
	}

	library := "OpenSSL"
	switch event.Library {
	case 1:
		library = "BoringSSL"
	case 2:
		library = "Go"
	}

	// Extract plaintext
	plaintext := string(event.Data[:event.DataLen])

	slog.Info("TLS [] PID: TID: Len:\n", "direction", direction, "library", library, "p_i_d", event.PID, "t_i_d", event.TID, "data_len", event.DataLen, "plaintext", plaintext)
	// Send to Entropy Monitor for analysis
	// Send to APE Engine for intent extraction
}

// Close cleanup
func (ti *TLSInterceptor) Close() error {
	close(ti.stopChan)

	for _, l := range ti.links {
		l.Close()
	}

	if ti.reader != nil {
		ti.reader.Close()
	}

	return nil
}

// GetPlaintext returns plaintext from event
func (event *TLSEvent) GetPlaintext() string {
	return string(event.Data[:event.DataLen])
}

// GetProcessName returns process name
func (event *TLSEvent) GetProcessName() string {
	// Find null terminator
	for i, b := range event.Comm {
		if b == 0 {
			return string(event.Comm[:i])
		}
	}
	return string(event.Comm[:])
}
