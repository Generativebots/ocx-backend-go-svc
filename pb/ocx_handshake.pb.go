// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: pb/ocx_handshake.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type HandshakeState_State int32

const (
	HandshakeState_INIT                 HandshakeState_State = 0
	HandshakeState_HELLO_SENT           HandshakeState_State = 1
	HandshakeState_HELLO_RECEIVED       HandshakeState_State = 2
	HandshakeState_CHALLENGE_SENT       HandshakeState_State = 3
	HandshakeState_CHALLENGE_RECEIVED   HandshakeState_State = 4
	HandshakeState_PROOF_SENT           HandshakeState_State = 5
	HandshakeState_PROOF_RECEIVED       HandshakeState_State = 6
	HandshakeState_VERIFIED             HandshakeState_State = 7
	HandshakeState_ATTESTATION_SENT     HandshakeState_State = 8
	HandshakeState_ATTESTATION_RECEIVED HandshakeState_State = 9
	HandshakeState_ACCEPTED             HandshakeState_State = 10
	HandshakeState_REJECTED             HandshakeState_State = 11
	HandshakeState_TIMEOUT              HandshakeState_State = 12
	HandshakeState_ERROR                HandshakeState_State = 13
)

// Enum value maps for HandshakeState_State.
var (
	HandshakeState_State_name = map[int32]string{
		0:  "INIT",
		1:  "HELLO_SENT",
		2:  "HELLO_RECEIVED",
		3:  "CHALLENGE_SENT",
		4:  "CHALLENGE_RECEIVED",
		5:  "PROOF_SENT",
		6:  "PROOF_RECEIVED",
		7:  "VERIFIED",
		8:  "ATTESTATION_SENT",
		9:  "ATTESTATION_RECEIVED",
		10: "ACCEPTED",
		11: "REJECTED",
		12: "TIMEOUT",
		13: "ERROR",
	}
	HandshakeState_State_value = map[string]int32{
		"INIT":                 0,
		"HELLO_SENT":           1,
		"HELLO_RECEIVED":       2,
		"CHALLENGE_SENT":       3,
		"CHALLENGE_RECEIVED":   4,
		"PROOF_SENT":           5,
		"PROOF_RECEIVED":       6,
		"VERIFIED":             7,
		"ATTESTATION_SENT":     8,
		"ATTESTATION_RECEIVED": 9,
		"ACCEPTED":             10,
		"REJECTED":             11,
		"TIMEOUT":              12,
		"ERROR":                13,
	}
)

func (x HandshakeState_State) Enum() *HandshakeState_State {
	p := new(HandshakeState_State)
	*p = x
	return p
}

func (x HandshakeState_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HandshakeState_State) Descriptor() protoreflect.EnumDescriptor {
	return file_pb_ocx_handshake_proto_enumTypes[0].Descriptor()
}

func (HandshakeState_State) Type() protoreflect.EnumType {
	return &file_pb_ocx_handshake_proto_enumTypes[0]
}

func (x HandshakeState_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HandshakeState_State.Descriptor instead.
func (HandshakeState_State) EnumDescriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{7, 0}
}

// Step 1: HELLO - Initial capability exchange
type HandshakeHello struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the OCX instance
	InstanceId string `protobuf:"bytes,1,opt,name=instance_id,json=instanceId,proto3" json:"instance_id,omitempty"`
	// Organization name
	Organization string `protobuf:"bytes,2,opt,name=organization,proto3" json:"organization,omitempty"`
	// Protocol version (e.g., "1.0")
	ProtocolVersion string `protobuf:"bytes,3,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	// Supported capabilities
	Capabilities []string `protobuf:"bytes,4,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	// SPIFFE ID for identity verification
	SpiffeId string `protobuf:"bytes,5,opt,name=spiffe_id,json=spiffeId,proto3" json:"spiffe_id,omitempty"`
	// Public key for signature verification (PEM format)
	PublicKey string `protobuf:"bytes,6,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Timestamp of hello message (Unix seconds)
	Timestamp int64 `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Optional metadata
	Metadata      map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeHello) Reset() {
	*x = HandshakeHello{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeHello) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeHello) ProtoMessage() {}

func (x *HandshakeHello) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeHello.ProtoReflect.Descriptor instead.
func (*HandshakeHello) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{0}
}

func (x *HandshakeHello) GetInstanceId() string {
	if x != nil {
		return x.InstanceId
	}
	return ""
}

func (x *HandshakeHello) GetOrganization() string {
	if x != nil {
		return x.Organization
	}
	return ""
}

func (x *HandshakeHello) GetProtocolVersion() string {
	if x != nil {
		return x.ProtocolVersion
	}
	return ""
}

func (x *HandshakeHello) GetCapabilities() []string {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *HandshakeHello) GetSpiffeId() string {
	if x != nil {
		return x.SpiffeId
	}
	return ""
}

func (x *HandshakeHello) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *HandshakeHello) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *HandshakeHello) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Step 2: CHALLENGE - Cryptographic challenge with nonce
type HandshakeChallenge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Random nonce for replay protection (32 bytes, hex-encoded)
	Nonce string `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Cryptographic challenge (HMAC-SHA256 of nonce + instance_id)
	Challenge []byte `protobuf:"bytes,2,opt,name=challenge,proto3" json:"challenge,omitempty"`
	// Challenge type (e.g., "HMAC-SHA256")
	ChallengeType string `protobuf:"bytes,3,opt,name=challenge_type,json=challengeType,proto3" json:"challenge_type,omitempty"`
	// Timestamp of challenge (Unix seconds)
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Difficulty level (for future proof-of-work)
	Difficulty int32 `protobuf:"varint,5,opt,name=difficulty,proto3" json:"difficulty,omitempty"`
	// Expected capabilities from remote OCX
	RequiredCapabilities []string `protobuf:"bytes,6,rep,name=required_capabilities,json=requiredCapabilities,proto3" json:"required_capabilities,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *HandshakeChallenge) Reset() {
	*x = HandshakeChallenge{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeChallenge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeChallenge) ProtoMessage() {}

func (x *HandshakeChallenge) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeChallenge.ProtoReflect.Descriptor instead.
func (*HandshakeChallenge) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{1}
}

func (x *HandshakeChallenge) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *HandshakeChallenge) GetChallenge() []byte {
	if x != nil {
		return x.Challenge
	}
	return nil
}

func (x *HandshakeChallenge) GetChallengeType() string {
	if x != nil {
		return x.ChallengeType
	}
	return ""
}

func (x *HandshakeChallenge) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *HandshakeChallenge) GetDifficulty() int32 {
	if x != nil {
		return x.Difficulty
	}
	return 0
}

func (x *HandshakeChallenge) GetRequiredCapabilities() []string {
	if x != nil {
		return x.RequiredCapabilities
	}
	return nil
}

// Step 3: PROOF - Zero-knowledge proof response
type HandshakeProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signature of the challenge using private key
	Proof []byte `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Hash of audit trail for zero-knowledge verification
	AuditHash []byte `protobuf:"bytes,2,opt,name=audit_hash,json=auditHash,proto3" json:"audit_hash,omitempty"`
	// Digital signature of the proof
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Certificate chain (PEM format)
	CertificateChain []string `protobuf:"bytes,4,rep,name=certificate_chain,json=certificateChain,proto3" json:"certificate_chain,omitempty"`
	// Timestamp of proof generation (Unix seconds)
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Proof type (e.g., "ECDSA-SHA256")
	ProofType     string `protobuf:"bytes,6,opt,name=proof_type,json=proofType,proto3" json:"proof_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeProof) Reset() {
	*x = HandshakeProof{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeProof) ProtoMessage() {}

func (x *HandshakeProof) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeProof.ProtoReflect.Descriptor instead.
func (*HandshakeProof) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{2}
}

func (x *HandshakeProof) GetProof() []byte {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *HandshakeProof) GetAuditHash() []byte {
	if x != nil {
		return x.AuditHash
	}
	return nil
}

func (x *HandshakeProof) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *HandshakeProof) GetCertificateChain() []string {
	if x != nil {
		return x.CertificateChain
	}
	return nil
}

func (x *HandshakeProof) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *HandshakeProof) GetProofType() string {
	if x != nil {
		return x.ProofType
	}
	return ""
}

// Step 4: VERIFY - Mutual verification result
type HandshakeVerify struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the proof was successfully verified
	Verified bool `protobuf:"varint,1,opt,name=verified,proto3" json:"verified,omitempty"`
	// Trust level calculated from verification (0.0 - 1.0)
	TrustLevel float64 `protobuf:"fixed64,2,opt,name=trust_level,json=trustLevel,proto3" json:"trust_level,omitempty"`
	// Timestamp of verification (Unix seconds)
	VerifiedAt int64 `protobuf:"varint,3,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at,omitempty"`
	// Verification details
	Details *VerificationDetails `protobuf:"bytes,4,opt,name=details,proto3" json:"details,omitempty"`
	// Any verification errors or warnings
	Warnings      []string `protobuf:"bytes,5,rep,name=warnings,proto3" json:"warnings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeVerify) Reset() {
	*x = HandshakeVerify{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeVerify) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeVerify) ProtoMessage() {}

func (x *HandshakeVerify) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeVerify.ProtoReflect.Descriptor instead.
func (*HandshakeVerify) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{3}
}

func (x *HandshakeVerify) GetVerified() bool {
	if x != nil {
		return x.Verified
	}
	return false
}

func (x *HandshakeVerify) GetTrustLevel() float64 {
	if x != nil {
		return x.TrustLevel
	}
	return 0
}

func (x *HandshakeVerify) GetVerifiedAt() int64 {
	if x != nil {
		return x.VerifiedAt
	}
	return 0
}

func (x *HandshakeVerify) GetDetails() *VerificationDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *HandshakeVerify) GetWarnings() []string {
	if x != nil {
		return x.Warnings
	}
	return nil
}

// Verification details sub-message
type VerificationDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether audit hash matches
	AuditHashMatch bool `protobuf:"varint,1,opt,name=audit_hash_match,json=auditHashMatch,proto3" json:"audit_hash_match,omitempty"`
	// Whether signature is valid
	SignatureValid bool `protobuf:"varint,2,opt,name=signature_valid,json=signatureValid,proto3" json:"signature_valid,omitempty"`
	// Whether certificate chain is valid
	CertificateValid bool `protobuf:"varint,3,opt,name=certificate_valid,json=certificateValid,proto3" json:"certificate_valid,omitempty"`
	// Whether nonce is fresh (not replayed)
	NonceFresh bool `protobuf:"varint,4,opt,name=nonce_fresh,json=nonceFresh,proto3" json:"nonce_fresh,omitempty"`
	// Audit score (0.0 - 1.0)
	AuditScore float64 `protobuf:"fixed64,5,opt,name=audit_score,json=auditScore,proto3" json:"audit_score,omitempty"`
	// Reputation score (0.0 - 1.0)
	ReputationScore float64 `protobuf:"fixed64,6,opt,name=reputation_score,json=reputationScore,proto3" json:"reputation_score,omitempty"`
	// Attestation score (0.0 - 1.0)
	AttestationScore float64 `protobuf:"fixed64,7,opt,name=attestation_score,json=attestationScore,proto3" json:"attestation_score,omitempty"`
	// History score (0.0 - 1.0)
	HistoryScore  float64 `protobuf:"fixed64,8,opt,name=history_score,json=historyScore,proto3" json:"history_score,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VerificationDetails) Reset() {
	*x = VerificationDetails{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VerificationDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VerificationDetails) ProtoMessage() {}

func (x *VerificationDetails) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VerificationDetails.ProtoReflect.Descriptor instead.
func (*VerificationDetails) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{4}
}

func (x *VerificationDetails) GetAuditHashMatch() bool {
	if x != nil {
		return x.AuditHashMatch
	}
	return false
}

func (x *VerificationDetails) GetSignatureValid() bool {
	if x != nil {
		return x.SignatureValid
	}
	return false
}

func (x *VerificationDetails) GetCertificateValid() bool {
	if x != nil {
		return x.CertificateValid
	}
	return false
}

func (x *VerificationDetails) GetNonceFresh() bool {
	if x != nil {
		return x.NonceFresh
	}
	return false
}

func (x *VerificationDetails) GetAuditScore() float64 {
	if x != nil {
		return x.AuditScore
	}
	return 0
}

func (x *VerificationDetails) GetReputationScore() float64 {
	if x != nil {
		return x.ReputationScore
	}
	return 0
}

func (x *VerificationDetails) GetAttestationScore() float64 {
	if x != nil {
		return x.AttestationScore
	}
	return 0
}

func (x *VerificationDetails) GetHistoryScore() float64 {
	if x != nil {
		return x.HistoryScore
	}
	return 0
}

// Step 5: ATTESTATION - Trust attestation exchange
type HandshakeAttestation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Final calculated trust level (0.0 - 1.0)
	TrustLevel float64 `protobuf:"fixed64,1,opt,name=trust_level,json=trustLevel,proto3" json:"trust_level,omitempty"`
	// Trust tax to be applied (0.0 - 1.0)
	TrustTax float64 `protobuf:"fixed64,2,opt,name=trust_tax,json=trustTax,proto3" json:"trust_tax,omitempty"`
	// Expiration timestamp for this attestation (Unix seconds)
	ExpiresAt int64 `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Unique attestation identifier
	AttestationId string `protobuf:"bytes,4,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id,omitempty"`
	// Ledger transaction ID for attestation
	LedgerTxId string `protobuf:"bytes,5,opt,name=ledger_tx_id,json=ledgerTxId,proto3" json:"ledger_tx_id,omitempty"`
	// Attestation signature
	AttestationSignature []byte `protobuf:"bytes,6,opt,name=attestation_signature,json=attestationSignature,proto3" json:"attestation_signature,omitempty"`
	// Additional attestation metadata
	Metadata      map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeAttestation) Reset() {
	*x = HandshakeAttestation{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeAttestation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeAttestation) ProtoMessage() {}

func (x *HandshakeAttestation) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeAttestation.ProtoReflect.Descriptor instead.
func (*HandshakeAttestation) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{5}
}

func (x *HandshakeAttestation) GetTrustLevel() float64 {
	if x != nil {
		return x.TrustLevel
	}
	return 0
}

func (x *HandshakeAttestation) GetTrustTax() float64 {
	if x != nil {
		return x.TrustTax
	}
	return 0
}

func (x *HandshakeAttestation) GetExpiresAt() int64 {
	if x != nil {
		return x.ExpiresAt
	}
	return 0
}

func (x *HandshakeAttestation) GetAttestationId() string {
	if x != nil {
		return x.AttestationId
	}
	return ""
}

func (x *HandshakeAttestation) GetLedgerTxId() string {
	if x != nil {
		return x.LedgerTxId
	}
	return ""
}

func (x *HandshakeAttestation) GetAttestationSignature() []byte {
	if x != nil {
		return x.AttestationSignature
	}
	return nil
}

func (x *HandshakeAttestation) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Step 6: ACCEPT/REJECT - Final handshake decision
type HandshakeResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Verdict: "ACCEPTED" or "REJECTED"
	Verdict string `protobuf:"bytes,1,opt,name=verdict,proto3" json:"verdict,omitempty"`
	// Human-readable reason for the verdict
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// Final trust level
	TrustLevel float64 `protobuf:"fixed64,3,opt,name=trust_level,json=trustLevel,proto3" json:"trust_level,omitempty"`
	// Session ID for accepted handshakes
	SessionId string `protobuf:"bytes,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Timestamp of completion (Unix seconds)
	CompletedAt int64 `protobuf:"varint,5,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	// Session expiration (Unix seconds, only for ACCEPTED)
	SessionExpiresAt int64 `protobuf:"varint,6,opt,name=session_expires_at,json=sessionExpiresAt,proto3" json:"session_expires_at,omitempty"`
	// Handshake duration in milliseconds
	DurationMs int64 `protobuf:"varint,7,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// Additional result metadata
	Metadata      map[string]string `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeResult) Reset() {
	*x = HandshakeResult{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeResult) ProtoMessage() {}

func (x *HandshakeResult) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeResult.ProtoReflect.Descriptor instead.
func (*HandshakeResult) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{6}
}

func (x *HandshakeResult) GetVerdict() string {
	if x != nil {
		return x.Verdict
	}
	return ""
}

func (x *HandshakeResult) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *HandshakeResult) GetTrustLevel() float64 {
	if x != nil {
		return x.TrustLevel
	}
	return 0
}

func (x *HandshakeResult) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *HandshakeResult) GetCompletedAt() int64 {
	if x != nil {
		return x.CompletedAt
	}
	return 0
}

func (x *HandshakeResult) GetSessionExpiresAt() int64 {
	if x != nil {
		return x.SessionExpiresAt
	}
	return 0
}

func (x *HandshakeResult) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *HandshakeResult) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// Handshake state for persistence and recovery
type HandshakeState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Handshake session ID
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Local OCX instance ID
	LocalInstanceId string `protobuf:"bytes,2,opt,name=local_instance_id,json=localInstanceId,proto3" json:"local_instance_id,omitempty"`
	// Remote OCX instance ID
	RemoteInstanceId string `protobuf:"bytes,3,opt,name=remote_instance_id,json=remoteInstanceId,proto3" json:"remote_instance_id,omitempty"`
	// Current state
	CurrentState HandshakeState_State `protobuf:"varint,4,opt,name=current_state,json=currentState,proto3,enum=federation.HandshakeState_State" json:"current_state,omitempty"`
	// Timestamp when handshake started (Unix seconds)
	StartedAt int64 `protobuf:"varint,5,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// Timestamp of last state transition (Unix seconds)
	LastUpdatedAt int64 `protobuf:"varint,6,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Handshake timeout (Unix seconds)
	TimeoutAt int64 `protobuf:"varint,7,opt,name=timeout_at,json=timeoutAt,proto3" json:"timeout_at,omitempty"`
	// Stored nonce for verification
	Nonce string `protobuf:"bytes,8,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Stored challenge for verification
	Challenge []byte `protobuf:"bytes,9,opt,name=challenge,proto3" json:"challenge,omitempty"`
	// Error message if any
	Error         string `protobuf:"bytes,10,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeState) Reset() {
	*x = HandshakeState{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeState) ProtoMessage() {}

func (x *HandshakeState) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeState.ProtoReflect.Descriptor instead.
func (*HandshakeState) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{7}
}

func (x *HandshakeState) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *HandshakeState) GetLocalInstanceId() string {
	if x != nil {
		return x.LocalInstanceId
	}
	return ""
}

func (x *HandshakeState) GetRemoteInstanceId() string {
	if x != nil {
		return x.RemoteInstanceId
	}
	return ""
}

func (x *HandshakeState) GetCurrentState() HandshakeState_State {
	if x != nil {
		return x.CurrentState
	}
	return HandshakeState_INIT
}

func (x *HandshakeState) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *HandshakeState) GetLastUpdatedAt() int64 {
	if x != nil {
		return x.LastUpdatedAt
	}
	return 0
}

func (x *HandshakeState) GetTimeoutAt() int64 {
	if x != nil {
		return x.TimeoutAt
	}
	return 0
}

func (x *HandshakeState) GetNonce() string {
	if x != nil {
		return x.Nonce
	}
	return ""
}

func (x *HandshakeState) GetChallenge() []byte {
	if x != nil {
		return x.Challenge
	}
	return nil
}

func (x *HandshakeState) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Wrapper message for streaming handshake
type HandshakeMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Message:
	//
	//	*HandshakeMessage_Hello
	//	*HandshakeMessage_Challenge
	//	*HandshakeMessage_Proof
	//	*HandshakeMessage_Verify
	//	*HandshakeMessage_Attestation
	//	*HandshakeMessage_Result
	Message       isHandshakeMessage_Message `protobuf_oneof:"message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeMessage) Reset() {
	*x = HandshakeMessage{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeMessage) ProtoMessage() {}

func (x *HandshakeMessage) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeMessage.ProtoReflect.Descriptor instead.
func (*HandshakeMessage) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{8}
}

func (x *HandshakeMessage) GetMessage() isHandshakeMessage_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *HandshakeMessage) GetHello() *HandshakeHello {
	if x != nil {
		if x, ok := x.Message.(*HandshakeMessage_Hello); ok {
			return x.Hello
		}
	}
	return nil
}

func (x *HandshakeMessage) GetChallenge() *HandshakeChallenge {
	if x != nil {
		if x, ok := x.Message.(*HandshakeMessage_Challenge); ok {
			return x.Challenge
		}
	}
	return nil
}

func (x *HandshakeMessage) GetProof() *HandshakeProof {
	if x != nil {
		if x, ok := x.Message.(*HandshakeMessage_Proof); ok {
			return x.Proof
		}
	}
	return nil
}

func (x *HandshakeMessage) GetVerify() *HandshakeVerify {
	if x != nil {
		if x, ok := x.Message.(*HandshakeMessage_Verify); ok {
			return x.Verify
		}
	}
	return nil
}

func (x *HandshakeMessage) GetAttestation() *HandshakeAttestation {
	if x != nil {
		if x, ok := x.Message.(*HandshakeMessage_Attestation); ok {
			return x.Attestation
		}
	}
	return nil
}

func (x *HandshakeMessage) GetResult() *HandshakeResult {
	if x != nil {
		if x, ok := x.Message.(*HandshakeMessage_Result); ok {
			return x.Result
		}
	}
	return nil
}

type isHandshakeMessage_Message interface {
	isHandshakeMessage_Message()
}

type HandshakeMessage_Hello struct {
	Hello *HandshakeHello `protobuf:"bytes,1,opt,name=hello,proto3,oneof"`
}

type HandshakeMessage_Challenge struct {
	Challenge *HandshakeChallenge `protobuf:"bytes,2,opt,name=challenge,proto3,oneof"`
}

type HandshakeMessage_Proof struct {
	Proof *HandshakeProof `protobuf:"bytes,3,opt,name=proof,proto3,oneof"`
}

type HandshakeMessage_Verify struct {
	Verify *HandshakeVerify `protobuf:"bytes,4,opt,name=verify,proto3,oneof"`
}

type HandshakeMessage_Attestation struct {
	Attestation *HandshakeAttestation `protobuf:"bytes,5,opt,name=attestation,proto3,oneof"`
}

type HandshakeMessage_Result struct {
	Result *HandshakeResult `protobuf:"bytes,6,opt,name=result,proto3,oneof"`
}

func (*HandshakeMessage_Hello) isHandshakeMessage_Message() {}

func (*HandshakeMessage_Challenge) isHandshakeMessage_Message() {}

func (*HandshakeMessage_Proof) isHandshakeMessage_Message() {}

func (*HandshakeMessage_Verify) isHandshakeMessage_Message() {}

func (*HandshakeMessage_Attestation) isHandshakeMessage_Message() {}

func (*HandshakeMessage_Result) isHandshakeMessage_Message() {}

// Request to get handshake status
type HandshakeStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SessionId     string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HandshakeStatusRequest) Reset() {
	*x = HandshakeStatusRequest{}
	mi := &file_pb_ocx_handshake_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HandshakeStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HandshakeStatusRequest) ProtoMessage() {}

func (x *HandshakeStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_pb_ocx_handshake_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HandshakeStatusRequest.ProtoReflect.Descriptor instead.
func (*HandshakeStatusRequest) Descriptor() ([]byte, []int) {
	return file_pb_ocx_handshake_proto_rawDescGZIP(), []int{9}
}

func (x *HandshakeStatusRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

var File_pb_ocx_handshake_proto protoreflect.FileDescriptor

const file_pb_ocx_handshake_proto_rawDesc = "" +
	"\n" +
	"\x16pb/ocx_handshake.proto\x12\n" +
	"federation\"\x81\x03\n" +
	"\x0eHandshakeHello\x12\x1f\n" +
	"\vinstance_id\x18\x01 \x01(\tR\n" +
	"instanceId\x12\"\n" +
	"\forganization\x18\x02 \x01(\tR\forganization\x12)\n" +
	"\x10protocol_version\x18\x03 \x01(\tR\x0fprotocolVersion\x12\"\n" +
	"\fcapabilities\x18\x04 \x03(\tR\fcapabilities\x12\x1b\n" +
	"\tspiffe_id\x18\x05 \x01(\tR\bspiffeId\x12\x1d\n" +
	"\n" +
	"public_key\x18\x06 \x01(\tR\tpublicKey\x12\x1c\n" +
	"\ttimestamp\x18\a \x01(\x03R\ttimestamp\x12D\n" +
	"\bmetadata\x18\b \x03(\v2(.federation.HandshakeHello.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xe2\x01\n" +
	"\x12HandshakeChallenge\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\tR\x05nonce\x12\x1c\n" +
	"\tchallenge\x18\x02 \x01(\fR\tchallenge\x12%\n" +
	"\x0echallenge_type\x18\x03 \x01(\tR\rchallengeType\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x12\x1e\n" +
	"\n" +
	"difficulty\x18\x05 \x01(\x05R\n" +
	"difficulty\x123\n" +
	"\x15required_capabilities\x18\x06 \x03(\tR\x14requiredCapabilities\"\xcd\x01\n" +
	"\x0eHandshakeProof\x12\x14\n" +
	"\x05proof\x18\x01 \x01(\fR\x05proof\x12\x1d\n" +
	"\n" +
	"audit_hash\x18\x02 \x01(\fR\tauditHash\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12+\n" +
	"\x11certificate_chain\x18\x04 \x03(\tR\x10certificateChain\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\x12\x1d\n" +
	"\n" +
	"proof_type\x18\x06 \x01(\tR\tproofType\"\xc6\x01\n" +
	"\x0fHandshakeVerify\x12\x1a\n" +
	"\bverified\x18\x01 \x01(\bR\bverified\x12\x1f\n" +
	"\vtrust_level\x18\x02 \x01(\x01R\n" +
	"trustLevel\x12\x1f\n" +
	"\vverified_at\x18\x03 \x01(\x03R\n" +
	"verifiedAt\x129\n" +
	"\adetails\x18\x04 \x01(\v2\x1f.federation.VerificationDetailsR\adetails\x12\x1a\n" +
	"\bwarnings\x18\x05 \x03(\tR\bwarnings\"\xd4\x02\n" +
	"\x13VerificationDetails\x12(\n" +
	"\x10audit_hash_match\x18\x01 \x01(\bR\x0eauditHashMatch\x12'\n" +
	"\x0fsignature_valid\x18\x02 \x01(\bR\x0esignatureValid\x12+\n" +
	"\x11certificate_valid\x18\x03 \x01(\bR\x10certificateValid\x12\x1f\n" +
	"\vnonce_fresh\x18\x04 \x01(\bR\n" +
	"nonceFresh\x12\x1f\n" +
	"\vaudit_score\x18\x05 \x01(\x01R\n" +
	"auditScore\x12)\n" +
	"\x10reputation_score\x18\x06 \x01(\x01R\x0freputationScore\x12+\n" +
	"\x11attestation_score\x18\a \x01(\x01R\x10attestationScore\x12#\n" +
	"\rhistory_score\x18\b \x01(\x01R\fhistoryScore\"\xfa\x02\n" +
	"\x14HandshakeAttestation\x12\x1f\n" +
	"\vtrust_level\x18\x01 \x01(\x01R\n" +
	"trustLevel\x12\x1b\n" +
	"\ttrust_tax\x18\x02 \x01(\x01R\btrustTax\x12\x1d\n" +
	"\n" +
	"expires_at\x18\x03 \x01(\x03R\texpiresAt\x12%\n" +
	"\x0eattestation_id\x18\x04 \x01(\tR\rattestationId\x12 \n" +
	"\fledger_tx_id\x18\x05 \x01(\tR\n" +
	"ledgerTxId\x123\n" +
	"\x15attestation_signature\x18\x06 \x01(\fR\x14attestationSignature\x12J\n" +
	"\bmetadata\x18\a \x03(\v2..federation.HandshakeAttestation.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf9\x02\n" +
	"\x0fHandshakeResult\x12\x18\n" +
	"\averdict\x18\x01 \x01(\tR\averdict\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x1f\n" +
	"\vtrust_level\x18\x03 \x01(\x01R\n" +
	"trustLevel\x12\x1d\n" +
	"\n" +
	"session_id\x18\x04 \x01(\tR\tsessionId\x12!\n" +
	"\fcompleted_at\x18\x05 \x01(\x03R\vcompletedAt\x12,\n" +
	"\x12session_expires_at\x18\x06 \x01(\x03R\x10sessionExpiresAt\x12\x1f\n" +
	"\vduration_ms\x18\a \x01(\x03R\n" +
	"durationMs\x12E\n" +
	"\bmetadata\x18\b \x03(\v2).federation.HandshakeResult.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xfa\x04\n" +
	"\x0eHandshakeState\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12*\n" +
	"\x11local_instance_id\x18\x02 \x01(\tR\x0flocalInstanceId\x12,\n" +
	"\x12remote_instance_id\x18\x03 \x01(\tR\x10remoteInstanceId\x12E\n" +
	"\rcurrent_state\x18\x04 \x01(\x0e2 .federation.HandshakeState.StateR\fcurrentState\x12\x1d\n" +
	"\n" +
	"started_at\x18\x05 \x01(\x03R\tstartedAt\x12&\n" +
	"\x0flast_updated_at\x18\x06 \x01(\x03R\rlastUpdatedAt\x12\x1d\n" +
	"\n" +
	"timeout_at\x18\a \x01(\x03R\ttimeoutAt\x12\x14\n" +
	"\x05nonce\x18\b \x01(\tR\x05nonce\x12\x1c\n" +
	"\tchallenge\x18\t \x01(\fR\tchallenge\x12\x14\n" +
	"\x05error\x18\n" +
	" \x01(\tR\x05error\"\xf7\x01\n" +
	"\x05State\x12\b\n" +
	"\x04INIT\x10\x00\x12\x0e\n" +
	"\n" +
	"HELLO_SENT\x10\x01\x12\x12\n" +
	"\x0eHELLO_RECEIVED\x10\x02\x12\x12\n" +
	"\x0eCHALLENGE_SENT\x10\x03\x12\x16\n" +
	"\x12CHALLENGE_RECEIVED\x10\x04\x12\x0e\n" +
	"\n" +
	"PROOF_SENT\x10\x05\x12\x12\n" +
	"\x0ePROOF_RECEIVED\x10\x06\x12\f\n" +
	"\bVERIFIED\x10\a\x12\x14\n" +
	"\x10ATTESTATION_SENT\x10\b\x12\x18\n" +
	"\x14ATTESTATION_RECEIVED\x10\t\x12\f\n" +
	"\bACCEPTED\x10\n" +
	"\x12\f\n" +
	"\bREJECTED\x10\v\x12\v\n" +
	"\aTIMEOUT\x10\f\x12\t\n" +
	"\x05ERROR\x10\r\"\xf9\x02\n" +
	"\x10HandshakeMessage\x122\n" +
	"\x05hello\x18\x01 \x01(\v2\x1a.federation.HandshakeHelloH\x00R\x05hello\x12>\n" +
	"\tchallenge\x18\x02 \x01(\v2\x1e.federation.HandshakeChallengeH\x00R\tchallenge\x122\n" +
	"\x05proof\x18\x03 \x01(\v2\x1a.federation.HandshakeProofH\x00R\x05proof\x125\n" +
	"\x06verify\x18\x04 \x01(\v2\x1b.federation.HandshakeVerifyH\x00R\x06verify\x12D\n" +
	"\vattestation\x18\x05 \x01(\v2 .federation.HandshakeAttestationH\x00R\vattestation\x125\n" +
	"\x06result\x18\x06 \x01(\v2\x1b.federation.HandshakeResultH\x00R\x06resultB\t\n" +
	"\amessage\"7\n" +
	"\x16HandshakeStatusRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId2\xba\x03\n" +
	"\x18InterOCXHandshakeService\x12O\n" +
	"\x11InitiateHandshake\x12\x1a.federation.HandshakeHello\x1a\x1e.federation.HandshakeChallenge\x12M\n" +
	"\x12RespondToChallenge\x12\x1a.federation.HandshakeProof\x1a\x1b.federation.HandshakeVerify\x12T\n" +
	"\x13ExchangeAttestation\x12 .federation.HandshakeAttestation\x1a\x1b.federation.HandshakeResult\x12R\n" +
	"\x10PerformHandshake\x12\x1c.federation.HandshakeMessage\x1a\x1c.federation.HandshakeMessage(\x010\x01\x12T\n" +
	"\x12GetHandshakeStatus\x12\".federation.HandshakeStatusRequest\x1a\x1a.federation.HandshakeStateB\x1bZ\x19github.com/ocx/backend/pbb\x06proto3"

var (
	file_pb_ocx_handshake_proto_rawDescOnce sync.Once
	file_pb_ocx_handshake_proto_rawDescData []byte
)

func file_pb_ocx_handshake_proto_rawDescGZIP() []byte {
	file_pb_ocx_handshake_proto_rawDescOnce.Do(func() {
		file_pb_ocx_handshake_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pb_ocx_handshake_proto_rawDesc), len(file_pb_ocx_handshake_proto_rawDesc)))
	})
	return file_pb_ocx_handshake_proto_rawDescData
}

var file_pb_ocx_handshake_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_pb_ocx_handshake_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_pb_ocx_handshake_proto_goTypes = []any{
	(HandshakeState_State)(0),      // 0: federation.HandshakeState.State
	(*HandshakeHello)(nil),         // 1: federation.HandshakeHello
	(*HandshakeChallenge)(nil),     // 2: federation.HandshakeChallenge
	(*HandshakeProof)(nil),         // 3: federation.HandshakeProof
	(*HandshakeVerify)(nil),        // 4: federation.HandshakeVerify
	(*VerificationDetails)(nil),    // 5: federation.VerificationDetails
	(*HandshakeAttestation)(nil),   // 6: federation.HandshakeAttestation
	(*HandshakeResult)(nil),        // 7: federation.HandshakeResult
	(*HandshakeState)(nil),         // 8: federation.HandshakeState
	(*HandshakeMessage)(nil),       // 9: federation.HandshakeMessage
	(*HandshakeStatusRequest)(nil), // 10: federation.HandshakeStatusRequest
	nil,                            // 11: federation.HandshakeHello.MetadataEntry
	nil,                            // 12: federation.HandshakeAttestation.MetadataEntry
	nil,                            // 13: federation.HandshakeResult.MetadataEntry
}
var file_pb_ocx_handshake_proto_depIdxs = []int32{
	11, // 0: federation.HandshakeHello.metadata:type_name -> federation.HandshakeHello.MetadataEntry
	5,  // 1: federation.HandshakeVerify.details:type_name -> federation.VerificationDetails
	12, // 2: federation.HandshakeAttestation.metadata:type_name -> federation.HandshakeAttestation.MetadataEntry
	13, // 3: federation.HandshakeResult.metadata:type_name -> federation.HandshakeResult.MetadataEntry
	0,  // 4: federation.HandshakeState.current_state:type_name -> federation.HandshakeState.State
	1,  // 5: federation.HandshakeMessage.hello:type_name -> federation.HandshakeHello
	2,  // 6: federation.HandshakeMessage.challenge:type_name -> federation.HandshakeChallenge
	3,  // 7: federation.HandshakeMessage.proof:type_name -> federation.HandshakeProof
	4,  // 8: federation.HandshakeMessage.verify:type_name -> federation.HandshakeVerify
	6,  // 9: federation.HandshakeMessage.attestation:type_name -> federation.HandshakeAttestation
	7,  // 10: federation.HandshakeMessage.result:type_name -> federation.HandshakeResult
	1,  // 11: federation.InterOCXHandshakeService.InitiateHandshake:input_type -> federation.HandshakeHello
	3,  // 12: federation.InterOCXHandshakeService.RespondToChallenge:input_type -> federation.HandshakeProof
	6,  // 13: federation.InterOCXHandshakeService.ExchangeAttestation:input_type -> federation.HandshakeAttestation
	9,  // 14: federation.InterOCXHandshakeService.PerformHandshake:input_type -> federation.HandshakeMessage
	10, // 15: federation.InterOCXHandshakeService.GetHandshakeStatus:input_type -> federation.HandshakeStatusRequest
	2,  // 16: federation.InterOCXHandshakeService.InitiateHandshake:output_type -> federation.HandshakeChallenge
	4,  // 17: federation.InterOCXHandshakeService.RespondToChallenge:output_type -> federation.HandshakeVerify
	7,  // 18: federation.InterOCXHandshakeService.ExchangeAttestation:output_type -> federation.HandshakeResult
	9,  // 19: federation.InterOCXHandshakeService.PerformHandshake:output_type -> federation.HandshakeMessage
	8,  // 20: federation.InterOCXHandshakeService.GetHandshakeStatus:output_type -> federation.HandshakeState
	16, // [16:21] is the sub-list for method output_type
	11, // [11:16] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_pb_ocx_handshake_proto_init() }
func file_pb_ocx_handshake_proto_init() {
	if File_pb_ocx_handshake_proto != nil {
		return
	}
	file_pb_ocx_handshake_proto_msgTypes[8].OneofWrappers = []any{
		(*HandshakeMessage_Hello)(nil),
		(*HandshakeMessage_Challenge)(nil),
		(*HandshakeMessage_Proof)(nil),
		(*HandshakeMessage_Verify)(nil),
		(*HandshakeMessage_Attestation)(nil),
		(*HandshakeMessage_Result)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_pb_ocx_handshake_proto_rawDesc), len(file_pb_ocx_handshake_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_pb_ocx_handshake_proto_goTypes,
		DependencyIndexes: file_pb_ocx_handshake_proto_depIdxs,
		EnumInfos:         file_pb_ocx_handshake_proto_enumTypes,
		MessageInfos:      file_pb_ocx_handshake_proto_msgTypes,
	}.Build()
	File_pb_ocx_handshake_proto = out.File
	file_pb_ocx_handshake_proto_goTypes = nil
	file_pb_ocx_handshake_proto_depIdxs = nil
}
