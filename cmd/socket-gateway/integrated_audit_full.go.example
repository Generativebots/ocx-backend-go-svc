package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"time"

	"github.com/ocx/backend/internal/gvisor"
	pb "github.com/ocx/backend/pb/jury"
	"google.golang.org/grpc"
)

// IntegratedSpeculativeAudit orchestrates the complete tri-factor pipeline
func IntegratedSpeculativeAudit(payload []byte, txID, agentID string) {
	log.Printf("ðŸ”® Starting Integrated Speculative Audit for %s", txID)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Parse MCP payload
	var toolCall gvisor.ToolCallPayload
	if err := json.Unmarshal(payload, &toolCall); err != nil {
		log.Printf("Failed to parse payload: %v", err)
		return
	}
	toolCall.TransactionID = txID
	toolCall.AgentID = agentID

	// 1. Clone State (prepare for speculative execution)
	snapshot, err := stateCloner.CloneState(ctx, txID, agentID)
	if err != nil {
		log.Printf("Failed to clone state: %v", err)
		return
	}

	log.Printf("ðŸ“¸ State snapshot created: %s", snapshot.SnapshotID)

	// 2. Parallel Branch: Jury Audit (gRPC)
	go sendToJuryGRPC(ctx, &toolCall)

	// 3. Parallel Branch: Entropy Monitor
	go sendToEntropyMonitor(ctx, payload, txID, agentID)

	// 4. Parallel Branch: gVisor Execution
	go func() {
		result, err := sandboxExecutor.ExecuteSpeculative(ctx, &toolCall)
		if err != nil {
			log.Printf("Speculative execution failed: %v", err)
			// Trigger revert
			stateCloner.RevertState(ctx, snapshot.RevertToken)
			return
		}

		// Sequester result in Escrow Gate
		escrowGate.SequesterResult(result)

		log.Printf("âœ… Speculative result sequestered: %s", txID)
	}()
}

// sendToJuryGRPC calls the Jury Auditor gRPC service
func sendToJuryGRPC(ctx context.Context, toolCall *gvisor.ToolCallPayload) {
	// Connect to Jury gRPC server
	conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
	if err != nil {
		log.Printf("Failed to connect to Jury: %v", err)
		return
	}
	defer conn.Close()

	client := pb.NewJuryAuditorClient(conn)

	// Prepare audit request
	params := make(map[string]string)
	for k, v := range toolCall.Parameters {
		params[k] = fmt.Sprintf("%v", v)
	}

	request := &pb.AuditRequest{
		TransactionId: toolCall.TransactionID,
		AgentId:       toolCall.AgentID,
		ToolName:      toolCall.ToolName,
		Parameters:    params,
	}

	// Call Jury (parallel to gVisor execution)
	response, err := client.AuditIntent(ctx, request)
	if err != nil {
		log.Printf("Jury audit failed: %v", err)
		// Default to FAIL on error
		escrowGate.RecordJuryVerdict(toolCall.TransactionID, toolCall.AgentID, "FAIL", "Audit error", 0.0)
		return
	}

	// Record verdict in Escrow Gate
	escrowGate.RecordJuryVerdict(
		toolCall.TransactionID,
		toolCall.AgentID,
		response.Verdict,
		response.Reason,
		response.Confidence,
	)

	log.Printf("âš–ï¸  Jury verdict: %s (confidence: %.2f, took %.3fs)",
		response.Verdict, response.Confidence, response.AuditTime)
}

// sendToEntropyMonitor analyzes payload entropy
func sendToEntropyMonitor(ctx context.Context, payload []byte, txID, agentID string) {
	// In production, this would call Python entropy monitor via HTTP/gRPC
	// For now, calculate entropy directly

	entropy := calculateEntropy(payload)
	baseline := 4.5
	deviation := abs(entropy - baseline)

	status := "CLEAR"
	reason := "Entropy within normal range"

	if deviation > 1.2 {
		status = "FLAGGED"
		if entropy > baseline {
			reason = fmt.Sprintf("High entropy (%.2f) suggests encrypted payload", entropy)
		} else {
			reason = fmt.Sprintf("Low entropy (%.2f) suggests repetitive patterns", entropy)
		}
	}

	// Record verdict in Escrow Gate
	escrowGate.RecordEntropyVerdict(txID, agentID, status, entropy, baseline)

	log.Printf("ðŸ“Š Entropy verdict: %s (score: %.2f, baseline: %.2f)", status, entropy, baseline)
}

// calculateEntropy computes Shannon entropy of payload
func calculateEntropy(data []byte) float64 {
	if len(data) == 0 {
		return 0.0
	}

	// Count byte frequencies
	counts := make(map[byte]int)
	for _, b := range data {
		counts[b]++
	}

	// Calculate Shannon entropy
	entropy := 0.0
	total := float64(len(data))

	for _, count := range counts {
		p := float64(count) / total
		entropy -= p * math.Log2(p)
	}

	return entropy
}

func abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}

// Update main.go to use integrated audit
func processSocketEvent(event *SocketEvent) {
	payload := event.Payload[:event.PayloadLen]
	txID := fmt.Sprintf("tx-%d", time.Now().UnixNano())
	agentID := fmt.Sprintf("pid-%d", event.PID)

	// Start integrated speculative audit
	IntegratedSpeculativeAudit(payload, txID, agentID)
}
